/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.14-log : Database - xblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`xblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

/*Table structure for table `mto_channels` */

DROP TABLE IF EXISTS `mto_channels`;

CREATE TABLE `mto_channels` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '频道编号',
  `key` varchar(255) DEFAULT NULL COMMENT '频道标识',
  `name` varchar(255) DEFAULT NULL COMMENT '频道名',
  `status` int(11) DEFAULT NULL COMMENT '频道状态',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `mto_channels` */

insert  into `mto_channels`(`id`,`key`,`name`,`status`) values (1,'blog','博客',0),(2,'questions','问答',0),(3,'share','分享',0);

/*Table structure for table `mto_comments` */

DROP TABLE IF EXISTS `mto_comments`;

CREATE TABLE `mto_comments` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论编号',
  `author_id` bigint(20) DEFAULT NULL COMMENT '作者编号',
  `content` varchar(255) DEFAULT NULL COMMENT '评论内容',
  `to_id` bigint(20) DEFAULT NULL COMMENT '评论的文章编号',
  `status` int(11) DEFAULT NULL COMMENT '评论状态',
  `created` datetime DEFAULT NULL COMMENT '评论时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `mto_comments` */

/*Table structure for table `mto_posts` */

DROP TABLE IF EXISTS `mto_posts`;

CREATE TABLE `mto_posts` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章编号',
  `author_id` bigint(20) DEFAULT NULL COMMENT '作者编号',
  `channel_id` bigint(20) DEFAULT NULL COMMENT '频道编号',
  `title` varchar(64) DEFAULT NULL COMMENT '文章标题',
  `content` longtext COMMENT '文章内容',
  `views` int(11) DEFAULT '0' COMMENT '文章阅读数',
  `comments` int(11) DEFAULT '0' COMMENT '评论数量',
  `favors` int(11) DEFAULT '0' COMMENT '喜欢数',
  `featured` int(11) DEFAULT '0' COMMENT '是否推荐',
  `status` int(11) DEFAULT '0' COMMENT '文章状态',
  `weight` int(11) DEFAULT NULL COMMENT '是否置顶',
  `created` datetime DEFAULT NULL COMMENT '文章产生时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;

/*Data for the table `mto_posts` */

insert  into `mto_posts`(`id`,`author_id`,`channel_id`,`title`,`content`,`views`,`comments`,`favors`,`featured`,`status`,`weight`,`created`) values (19,11,1,'深入理解JDK动态代理机制','<div>\r\n<p><strong>本文是基于jdk1.8来对动态代理的底层机制进行探究的</strong></p>\r\n<p><em>Java中代理的实现一般分为三种：JDK静态代理、JDK动态代理以及CGLIB动态代理。在Spring的AOP实现中，主要应用了JDK动态代理以及CGLIB动态代理。但是本文着重介绍JDK动态代理机制，CGLIB动态代理后面会接着探究。</em></p>\r\n<p>代理一般实现的模式为JDK静态代理：创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>\r\n<p><em>其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</em></p>\r\n</div>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"upload/editor/5B4CEECAD9B547B6BE9180C073E7CF69.png\" /></p>\r\n<p style=\"text-align: center;\">接口</p>\r\n<p style=\"text-align: center;\"><img src=\"upload/editor/3489B7670CB34DD9BDE840E0379BBADD.png\" /></p>\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\" style=\"text-align: center;\">被代理类</div>\r\n<div class=\"image-caption\" style=\"text-align: center;\"><img src=\"https://upload-images.jianshu.io/upload_images/2993097-d8f7025fa265aa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/576\" /></div>\r\n<div class=\"image-caption\" style=\"text-align: center;\">\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\">代理类</div>\r\n</div>\r\n<div class=\"image-package\">\r\n<div class=\"image-container\"><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"upload/editor/6D436C12E1594D129F17D6AE1EA20E99.png\" /></div>\r\n<div class=\"image-container\">\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\">测试类以及输出结果</div>\r\n<div class=\"image-caption\" style=\"text-align: left;\">我们可以看出，使用JDK静态代理很容易就完成了对一个类的代理操作。但是JDK静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<div class=\"image-package\">\r\n<div class=\"image-container\"><em>下面我们使用JDK动态代理来做同样的事情</em></div>\r\n<div class=\"image-container\">&nbsp;</div>\r\n<div class=\"image-container\" style=\"text-align: center;\"><img src=\"upload/editor/0FD6C3FF94F14AF59B07C4B75145E70E.png\" /></div>\r\n<div class=\"image-container\" style=\"text-align: center;\"><em>接口</em></div>\r\n<div class=\"image-container\" style=\"text-align: center;\"><img src=\"upload/editor/35795167AC284529BAEC7D98AB295422.png\" /></div>\r\n<div class=\"image-container\" style=\"text-align: center;\">\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\">被代理类</div>\r\n</div>\r\n<div class=\"image-package\">\r\n<div class=\"image-container\"><img src=\"upload/editor/089B7D81FED94C009C445CC5EACA3A95.png\" /></div>\r\n<div class=\"image-container\">\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\">代理类</div>\r\n</div>\r\n<div class=\"image-package\">\r\n<div class=\"image-container\"><img src=\"upload/editor/6024540CFE234CB59D3130A9C971555B.png\" /></div>\r\n<div class=\"image-container\">\r\n<div class=\"image-package\">\r\n<div class=\"image-caption\">测试类以及输出结果</div>\r\n<div class=\"image-caption\">\r\n<p>JDK动态代理其实也是基本接口实现的。因为通过接口指向实现类实例的多态方式，可以有效地将具体实现与调用解耦，便于后期的修改和维护。</p>\r\n<p>通过上面的介绍，我们可以发现JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。但是不同之处也非常明显----在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p>\r\n<p>让我们用一句话来总结一下JDK静态代理和JDK动态代理的区别，然后开始探究JDK动态代理的底层实现机制：<br /> JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。<br /> 其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的invoke方法。所以对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>\r\n<p>我们从JDK动态代理的测试类中可以发现代理类生成是通过Proxy类中的<strong>newProxyInstance</strong>来完成的。</p>\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>',22,0,0,0,0,0,'2018-05-27 01:04:48'),(20,11,1,'分页功能之PageBean','<p>一 JavaWeb实现分页的PageBean的属性介绍</p>\r\n<ol>\r\n<li>int total；总记录数，这个需要从数据库中查询得到</li>\r\n<li>int pageSize；每页显示的记录数，一般是设定好的具体数值</li>\r\n<li>int pageNumber；当前页码，从前端获取</li>\r\n<li>nt totalPage；总页数，计算得到；有许多方法，介绍其中一种：<code>totalPage = total % pageSize == 0 ? total / pageSize:total / pageSize + 1</code></li>\r\n<li>int startIndex；起始索引，计算得到：（pageNumber-1）*pageSize;&nbsp;<br />SqlServer：top关键字&nbsp;<br />Oracle：rownumber+嵌套子查询&nbsp;<br />MySQL :limit关键字，在此使用的MySQL的limit实现分页&nbsp;<br />这个是用来控制物理分页中SQL分页语句的。例如MySQL的limit关键字 的语法就有limit ?,?。&nbsp;<br />在此需要介绍一下limit关键字实现分页：MySQL的方言limit可以帮助我们实现物理分页（也就是在数据库端的分页），而limit的参数有两种情况:&nbsp;<br />\r\n<ul>\r\n<li>一个参数的情况：表示查询前多少条记录</li>\r\n<li>两个参数的情况：用于分页，第一页起始从索引0开始，第二页的起始索引为（当前页码-1）*每页显示的条数。</li>\r\n-</ul>\r\n</li>\r\n<li>List list;查询到的数据集合</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p>二 PageBean的抽取过程</p>\r\n<pre class=\"prettyprint\"><code class=\"hljs mathematica has-numbering\"><span class=\"hljs-number\">1.</span>首先，Servlet从jsp获取当前页码，然后传递给Service也就是业务逻辑层。\r\n\r\n<span class=\"hljs-number\">2.</span>service层接收到数据，并且设置pageSize大小;\r\n\r\n<span class=\"hljs-number\">3.</span>然后调用dao层查询数据库中的总的记录条数total和查询到的分页后的数据<span class=\"hljs-keyword\">List</span>返回给service层。\r\n\r\n<span class=\"hljs-number\">4.</span>service层就有了以下数据：total，pageSize，pageNumber，<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Product</span>&gt;\r\n\r\n<span class=\"hljs-number\">5.</span>通过计算可以得到totalPage和startIndex;\r\n\r\n<span class=\"hljs-number\">6.</span>问题来了：当我们考虑如何将总页数，查询到的结果<span class=\"hljs-keyword\">List</span>集合一块返回给Servlet呢？一个方法无法返回两个不同类型的数据。\r\n\r\n<span class=\"hljs-number\">7.</span>于是我们可以将以上的数据封装到PageBean中，通过PageBean这个JavaBean封装以上的数据，存取的时候只要操作这一个对象就行</code></pre>\r\n<p>三.话不多说上代码</p>\r\n<pre class=\"prettyprint\"><code class=\"has-numbering\">为了实现PageBean的通用性，将List的泛型就用T，在具体场景下再具体指定其泛型的类型。</code></pre>\r\n<pre class=\"language-java\"><code>public class PageBean&lt;T&gt; {\r\n    private int total;\r\n    private int totalPage;\r\n    private int pageNumber;\r\n    private int pageSize;\r\n    private int startIndex;\r\n    private List&lt;T&gt; products;\r\n\r\n    public int getTotal() {\r\n        return total;\r\n    }\r\n\r\n    public void setTotal(int total) {\r\n        this.total = total;\r\n    }\r\n\r\n    public int getTotalPage() {\r\n        return totalPage = this.total % this.pageSize == 0 ? \r\n                (this.total / this.pageSize) : (this.total/this.pageSize+1);\r\n    }\r\n\r\n    public void setTotalPage(int totalPage) {\r\n        this.totalPage = totalPage;\r\n    }\r\n\r\n    public int getPageNumber() {\r\n        return pageNumber;\r\n    }\r\n\r\n    public void setPageNumber(int pageNumber) {\r\n        this.pageNumber = pageNumber;\r\n    }\r\n\r\n    public int getPageSize() {\r\n        return pageSize;\r\n    }\r\n\r\n    public void setPageSize(int pageSize) {\r\n        this.pageSize = pageSize;\r\n    }\r\n\r\n    public int getStartIndex() {\r\n        return startIndex = this.pageSize * (this.pageNumber - 1);\r\n    }\r\n\r\n    public void setStartIndex(int startIndex) {\r\n        this.startIndex = startIndex;\r\n    }\r\n\r\n    public List&lt;T&gt; getProducts() {\r\n        return products;\r\n    }\r\n\r\n    public void setProducts(List&lt;T&gt; products) {\r\n        this.products = products;\r\n    }\r\n\r\n    public PageBean() {\r\n    }\r\n\r\n}</code></pre>\r\n<p>&nbsp;</p>',5,0,0,0,0,0,'2018-05-27 01:27:34'),(21,11,2,'怎样用通俗的语言解释REST，以及RESTful？','<div>\r\n<div>\r\n<p>http是目前在互联网上使用最多的协议，没有之一。</p>\r\n<p>可是http的创始人一直都觉得，在过去10几年来，所有的人都在错误的使用Http.</p>\r\n<p>&nbsp;</p>\r\n<p>这句话怎么说呢？</p>\r\n<p>如果说你要删除一个数据，以往的做法通常是 delete/{id}</p>\r\n<p>如果你要更新一个数据，可能是Post数据放Body，然后方法是 update/{id}， 或者是artichle/{id}?method=update</p>\r\n<p>&nbsp;</p>\r\n<p>这种做法让Roy Fielding很暴燥，他觉得这个世界不该这样的，所有的人都在误解而且在严重错误的误解Http的设计初衷，好比是发明了火药却只用它来做烟花爆竹。</p>\r\n<p>&nbsp;</p>\r\n<p>那么正确的使用方式是什么呢？如果你要看Rest各种特性，你恐怕真的很难理解Rest，但是如果你看错误的使用http的人倒底儿了哪些错，什么是Rest就特别容易理解了。</p>\r\n<p>&nbsp;</p>\r\n<p><strong>七宗罪的第一条，混乱。</strong></p>\r\n<p>一万个人心里有一万个Url的命名规则，Url是统一资源定位符，重点是资源。而很多人却把它当成了万金油，每一个独立的虚拟的网页都可以随意使用，各种操作都能够迭加。</p>\r\n<p>这是混乱的来源之一。</p>\r\n<p>&nbsp;</p>\r\n<p><strong>第二条，贪婪。</strong></p>\r\n<p>有状态和无状态全部混在一起。特别是在购物车或者是登录的应用中，经常刷新就丢失带来的用户体验简直棒棒哒。每一个请求并不能单独的响应一些功能，很多的功能混杂在一起里。</p>\r\n<p>&nbsp;</p>\r\n<p>这是人性贪婪的本质，也是各种Hack的起源，只要能够把问题解决掉，总会有人用他认为最方便的方式去解决问题，比如说汽车门把手坏掉了直接系根绳子当把手，emmmm这样确实很棒啊。</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><strong>第三条，无序。</strong></p>\r\n<p>返回的结果往往是很随意，各种错误信息本来就是用Http的状态码构成的，可是很多人还是喜欢把错误信息返回在返回值中。最常见的就是Code和Message，当然对于这一点，我个人是保留疑问的，我的观点是，Http本身的错误和服务器的内部错误还是需要在不断层面分开的，不能混在一起。可是在大神眼里并非如此，这个再议。</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>好了我编不下去了。</p>\r\n<p>那么怎么解决这些问题呢？强迫症患者的福音就是先颁规则，第一个规则就是明确Url是什么，该怎么用。</p>\r\n<p>就是所有的Url本质来讲，都应该是一种资源。一个独立的Url地址，就是对应一个独一无二的资源。</p>\r\n<p>怎么样？这种感觉是不是棒棒哒？一个冰淇淋，一个老师，一间房子，在Url上对应的都是一个资源，不会有多余的Url跟他对应，也不会表示有多个Url地址~~注意，这里点的是Url地址，并不是单独的参数，他就是一个/room/{room_id}这样的东西，举个栗子,/room/3242 这就表示3242号房间。</p>\r\n<p>&nbsp;</p>\r\n<p>这是一个清爽的世界啊，你想想，之前的Url是什么都要，我开房，可能是/open/room/3242 我要退房可能是/exit/3242/room，我要打理房间，可能是room/3242?method=clean.</p>\r\n<p>&nbsp;</p>\r\n<p>够了！这些乱七八糟的东西全够了，让世界回归清爽的本质，一间房，就是/room/3242 没有别的Url地址了。</p>\r\n<p>&nbsp;</p>\r\n<p>那我想要对这个资源有操作怎么办？</p>\r\n<p>这就是棒棒哒大神想出来的了，http有几种Method来着？</p>\r\n<p>get ,put ,post,delete，还有其他隐藏的4种。</p>\r\n<p>在过去的混乱世界里，经常用的就是Get和Post。如果不是因为Get不支持大数据传输，我想连Post都会有人使用。（想像一下Roy Fielding在愤怒的对着电脑屏幕喊，Http的Method一共有八个，你们为毛只逮着Get一只羊的毛薅薅薅薅薅）。</p>\r\n<p>&nbsp;</p>\r\n<p>而对资源最常见的操作是什么？CRUD，对不对，就是创建，读，更新，删除。再看Http的Method？是不是非常完美？其实也怪Fielding老爷子一开始命名不准确，如果刚开始就是把Get方法叫做Read，Put方法叫做Update，Post叫做Create这该多好。。。</p>\r\n<p>&nbsp;</p>\r\n<p>你用一个Get，大家又发现没什么限制没什么所谓，又很难理解Put和Post的差别，法无禁止即可为啊，呃，老爷子不要瞪我，我瞎说的。</p>\r\n<p>&nbsp;</p>\r\n<p>总之，这四种方法够不够你浪？你有本身找出来更多的对资源的操作来啊，我还有4个Method没用过呢。如果这4个真的不够了，有什么问题，大不了我再重新更改http协议啊。</p>\r\n<p>&nbsp;</p>\r\n<p>其实简单说，对于Rest理解到这里就够了。后续的东西，都是在这一条基础上空想出来的，比强迫症更强迫症，当然，无状态我是百分百支持的。</p>\r\n<p>以上的各种表述可能不太准确，也纯属是我的意淫和各种小道资料，并未考据，但是凭良心讲，我是早就看不惯黑暗年代里的Url命名风格了，所以当时最早接触到Rest的时候，瞬间就找到了真爱，我靠，这不就是我一直想要的答案吗？</p>\r\n<p>&nbsp;</p>\r\n<p>但是我一直想的仅仅是命名规范，从来没有把自己的思考角度放在一个url就是一个资源，所有的操作都是对资源的更改而言的角度上啊。</p>\r\n<p>所以你能理解到的程度，更多的就是在于你要弄清楚你要解决的什么问题，如果你的问题只是理解Rest，恐怕你很理解，如果你的问题是怎么解决Url混乱的问题，你反而很快能弄懂了~</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>最后，希望大家更好的记着这种思考和学习问题的方式，用这种心态多去理解Rest和Restful，写出一篇更严谨的文章来~~</p>\r\n</div>\r\n</div>',4,0,0,0,0,NULL,'2018-05-27 01:32:27'),(22,11,3,'Java.util包简单总结','<p>之前听一位老师讲过，学Java的程序员，lang包和util包至少是要过一遍的。&nbsp;<br />很惭愧的是，从入门到现在，我还没完整的探究过这两个基础包。&nbsp;<br />今天借着跟公司小伙伴分享的机会，把util包简单的梳理一遍。由于最近加班很多，此篇先做粗略总结，日后有时间再完善。</p>\r\n<h1 id=\"1-util包的框架\"><a name=\"t0\"></a>1.&nbsp;<strong>util包的框架</strong></h1>\r\n<p>常用的集合类主要实现两个&ldquo;super接口&rdquo;而来：<code>Collection</code>和<code>Map</code>。</p>\r\n<h3 id=\"11-collection有两个子接口list和set\"><a name=\"t1\"></a>1.1&nbsp;<strong><code>Collection</code>有两个子接口：<code>List</code>和<code>Set</code></strong></h3>\r\n<p><strong><img src=\"upload/editor/EA69FC0308CD4BB6BD87285D2B22C354.png\" /></strong></p>\r\n<p><code>List</code>特点是<strong>元素有序，且可重复</strong>。实现的常用集合类有<code>ArrayList</code>、<code>LinkedList</code>，和<code>Vector</code>（线程安全）。</p>\r\n<p><code>Set</code>特点是<strong>元素无序，不可重复</strong>。实现的常用集合类有<code>HashSet</code>，<code>LinkedHashSet</code>，<code>TreeSet</code>（可排序）</p>\r\n<h3 id=\"12-map是keyvalue键值对的集合\">1.2&nbsp;<strong><code>Map</code>是key、value键值对的集合</strong></h3>\r\n<p><strong><img src=\"upload/editor/4BD60C7D4EA5437EBDD8E782ECF353D2.png\" /></strong></p>\r\n<p><strong>特点是key值无序不可重复，value值可重复（这样表述其实不太准确，因为实际上key和value是绑定在一起的）。常用的有<code>HashMap</code>，<code>HashTable</code>（线程安全），<code>TreeMap</code>（可排序）。</strong></p>\r\n<h3 id=\"13-其余重要接口和类\">1.3&nbsp;<strong>其余重要接口和类</strong></h3>\r\n<p>上面是util包中的集合框架，一般Java教材里面都会讲到。但我们深入研究一下，会发现还有其余几个重要的内容：</p>\r\n<ul>\r\n<li><strong>Iterator：迭代接口</strong>&nbsp;<br />集合类实现该接口后便具有了迭代功能。最简单的迭代实现是<code>ArrayList</code>，迭代过程其实就是数组的迭代。<code>LinkedList</code>、<code>LinkedHashSet</code>和<code>LinkedHashMap</code>迭代过程就是链表的迭代。这两者的迭代效率都很高，迭代时间与容器里的元素数目成正比。但<code>HashSet</code>、<code>HashMap</code>迭代效率就略低了，因为采用了哈希表，所以元素是散列在数组中的，迭代时必须读完整个数组，迭代时间与容器的容量成正比。</li>\r\n<li><strong>Comparator：比较接口</strong>&nbsp;<br />实现该接口后，集合内元素便可比较通过<code>compare()</code>方法实现元素排序</li>\r\n<li><strong>AbstractXXX：骨架类</strong>&nbsp;<br />所谓骨架类，其实就是不同集合的核心代码实现，让继承这个抽象类的子类少干点活。例如<code>AbstarctList</code>代表&ldquo;随机访问&rdquo;集合（底层数组实现）的骨干代码实现。<code>AbstractSequentialList</code>代表&ldquo;连续访问&rdquo;（底层链表实现）集合的骨干代码实现。</li>\r\n<li><strong>Collections、Arrays</strong>&nbsp;<br />集合工具类和数组工具类。Java中的工具类好像都喜欢在对应的接口或类名称后，加<code>S</code>来表示其工具类。</li>\r\n</ul>\r\n<p>接下来给一张比较完整的util包框架图：</p>\r\n<p><img src=\"upload/editor/FB569A7C1F5C43DFADBE7C3AEDB33E26.jpg\" /></p>\r\n<h1 id=\"2-常用集合类原理\">2. 常用集合类原理</h1>\r\n<h3 id=\"21-arraylist\"><a name=\"t5\"></a>2.1 ArrayList</h3>\r\n<p><code>ArrayList</code>的实现最简单，采用的顺序表，底层就是一个<code>Object</code>数组，初始容量为10，每当元素要超过容量时，重新创建一个更大的数组，并把原数据拷到新数组中来。</p>\r\n<h3 id=\"22-linkedlist\"><a name=\"t6\"></a>2.2 LinkedList</h3>\r\n<p><code>LinkedList</code>采用双向链表。集合中的每一个元素都会有两个成员变量<code>prev</code>和<code>next</code>，分别指向它的前一元素和后一元素。</p>\r\n<p><code>ArrayList</code>和<code>LinkedList</code>的区别这里就不详细讨论了，其实就是顺序表和链表两种数据结构的区别。之前写的博文中已经提到（包括<code>ArrayList</code>和<code>LinkedList</code>的详细实现）：&nbsp;<br /><a href=\"http://blog.csdn.net/z55887/article/details/50365338\" target=\"_blank\" rel=\"noopener\">数据结构基础（一）线性表</a></p>\r\n<h3 id=\"23-vector\"><a name=\"t7\"></a>2.3 Vector</h3>\r\n<p><code>Vector</code>底层实现和<code>ArrayList</code>类似，区别在于在许多方法上加了<code>synchronized</code>关键字，来实现了多线程安全。但代价是性能的降低。由于加锁的是整个集合，所以并发情况下进行迭代会锁住很长时间。</p>\r\n<h3 id=\"24-hashmap\"><a name=\"t8\"></a>2.4 HashMap</h3>\r\n<p><code>HashMap</code>采用的是哈希表结构，用链表法来解决hash冲突。这里不详细讨论，之前的文章写过：&nbsp;<br /><a href=\"http://blog.csdn.net/z55887/article/details/50596588\" target=\"_blank\" rel=\"noopener\">HashMap原理解析</a></p>\r\n<h3 id=\"25-hashtable\"><a name=\"t9\"></a>2.5 HashTable</h3>\r\n<p><code>HashTable</code>的底层实现和<code>HashMap</code>类似，区别也是在许多方法上加了<code>synchronized</code>关键字，来实现了多线程安全。</p>\r\n<h3 id=\"26-linkedhashmap\"><a name=\"t10\"></a>2.6 LinkedHashMap</h3>\r\n<p>在<code>HashMap</code>的基础上加了双链表，该集合中的每个元素也都保留了前一个元素和后一个元素的&ldquo;指针&rdquo;。这样便可以按照插入顺序来读取集合元素。也可设置为按照访问顺序来读取集合元素。&nbsp;<br />由于要维护额外的双链表，<code>LinkedHashMap</code>增删操作会比<code>HashMap</code>慢，但迭代时会比<code>HashMap</code>快。</p>\r\n<h3 id=\"27-treemap\"><a name=\"t11\"></a>2.7 TreeMap</h3>\r\n<p>采用了红黑树数据结构，从而实现了有序集合。这个比较复杂，以后单独开出一篇来讨论，此处略。</p>\r\n<h3 id=\"28-hashsetlinkedhashsettreeset\"><a name=\"t12\"></a>2.8 HashSet、LinkedHashSet、TreeSet</h3>\r\n<p>Set和Map有千丝万缕的联系呀。例如<code>HashSet</code>底层实现其实就是一个固定value的<code>HashMap</code>。LinkedHashSet就是一个value固定的<code>LinkedHashMap</code>，<code>TreeSet</code>就是一个value固定的<code>TreeMap</code>。</p>\r\n<h1 id=\"3-集合的并发\"><a name=\"t13\"></a>3. 集合的并发</h1>\r\n<h3 id=\"31-并发类的选择\"><a name=\"t14\"></a>3.1 并发类的选择</h3>\r\n<p>讲到并发的集合，一般都想到util包中的两个类：<code>HashTable</code>和<code>Vector</code>。然而实际使用情况中，并不推荐使用这两个类。</p>\r\n<p>首先，<code>HashTable</code>和<code>Vector</code>是从JDK1.0便存在的&ldquo;古老&rdquo;类，当时<code>Collection</code>、<code>Map</code>接口都还没。这样导致的问题是，当后来<code>HashTable</code>和<code>Vector</code>实现<code>Map</code>，<code>Collection</code>接口时，出现了许多无用而重复的方法。例如<code>Vector</code>原本有一个<code>addElement()</code>的方法，当实现了<code>Collection</code>接口后，又出现了一个<code>add()</code>方法。而实际上，这两个方法一模一样。</p>\r\n<p>替代的这两个并发类的常见方法是<code>Collections.synchronizedXXX(&hellip;)</code>，这个方法可以把<code>ArrayList</code>，<code>HashMap</code>等集合变为线程安全的集合类。</p>\r\n<p>那么，<code>Vector</code>和<code>Collections.synchronizedXXX(&hellip;)</code>的底层实现有什么区别呢？</p>\r\n<p>我们来看看两者的<code>add()</code>方法实现：</p>\r\n<pre class=\"language-java\"><code>//Vector\r\n    public synchronized boolean add(E e) {\r\n        modCount++;\r\n        ensureCapacityHelper(elementCount + 1);\r\n        elementData[elementCount++] = e;\r\n        return true;\r\n    }\r\n\r\n    //Collections.SynchronizedList\r\n    public void add(int index, E element) {\r\n        synchronized (mutex) {list.add(index, element);}\r\n    }</code></pre>\r\n<p>可以看出， 两者实现多线程的方式都是对集合的方法加锁，区别在于，<code>Vector</code>是对方法加锁，锁的是本对象，而<code>Collections.synchronizedXXX(&hellip;)</code>是对一个变量加锁。区别并不大。</p>\r\n<p>那么，既然<code>Collections.synchronizedXXX(&hellip;)</code>比较好，用它创建出线程安全的集合类是不是就一劳永逸的满足我们所有的需求了呢？很不幸，不完全是。</p>\r\n<p><code>Collections.synchronizedXXX(&hellip;)</code>和<code>HashTable</code>、<code>Vector</code>在高并发时都有着很大的性能缺陷。因为它们的增、删、取都会锁住整个集合。想一想，一个线程在迭代十万个元素的Vector，其余线程对集合的操作时不时就阻塞了，受到了多大的影响啊。</p>\r\n<p>为了解决这两种方法在高并发下的性能的低下。我们查找一下Java的API，发现在<code>java.util.concurrent</code>里面有许多针对高并发设计的类，例如：<code>CopyOnWriteArrayList</code>和<code>ConcurrentHashMap</code>。</p>\r\n<p><code>ConcurrentHashMap</code>的优化原理在于，采用了<code>Segment</code>的机制：</p>\r\n<p><img src=\"upload/editor/64738615CD944CF2911E0F9C760F5B9B.png\" /></p>\r\n<p>可以看成，<code>ConcurrentHashMap</code>底层每一个Segment都是一个<code>HashMap</code>,这样增删取时只需要锁住一段的<code>Segment</code>，而不是整个集合。从而优化了高并发下的性能。</p>\r\n<p><code>CopyOnWriteArrayList</code>主要是对高并发下的读、迭代做优化。实现原理在于每次<code>add</code>,<code>remove</code>操作都是重新创建一个新的数组，等操作结束再把引用指向新的数组。<code>add</code>,<code>remove</code>都是加了锁的，而<code>get</code>方法没有加锁，因为每次迭代时都是在旧的数组上迭代。所以<code>CopyOnWriteArrayList</code>适用于读多写少的并发场景。</p>',8,0,0,0,0,0,'2018-05-27 01:33:36'),(23,11,3,'java线程安全之并发Queue','<h2 id=\"并发queue\">并发Queue</h2>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在并发的队列上jdk提供了两套实现，一个是以ConcurrentLinkedQueue为代表的高性能队列，一个是以BlockingQueue接口为代表的阻塞队列，无论在那种都继承自Queue。&nbsp;<br />如图继承Queue共有二十四个：&nbsp;</p>\r\n<p><img src=\"upload/editor/40208049D8454989BA5FE170F811AF2C.jpg\" /></p>\r\n<p><img src=\"upload/editor/D6782FFD5D1F470187449D4CF9AB6559.jpg\" /></p>\r\n<h4 id=\"concurrentlinkedqueue\"><strong>oncurrentLinkedQueue</strong></h4>\r\n<h5 id=\"概念理解\"><strong>概念理解</strong></h5>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentLinkedQueue：是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueueo它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先讲先出的原则。头是最先加入的，尾是最近加入的，该队列不允许null元素。&nbsp;<br />ConcurrentLinkedQueue重要方法：</p>\r\n<p>Add()和offer()都是加入元素的方法（在ConcurrentLinkedQueue中，这两个方法投有任何区别）</p>\r\n<p>Poll()和peek()都是取头元素节点，区别在于前者会删除元素，后者不会。</p>\r\n<h5 id=\"案例\"><strong>案例</strong></h5>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-java\"><code>public class UseQueue_ConcurrentLinkedQueue {\r\n\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        //高性能无阻塞无界队列：ConcurrentLinkedQueue\r\n\r\n        ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();\r\n        q.offer(\"a\");\r\n        q.offer(\"b\");\r\n        q.offer(\"c\");\r\n        q.offer(\"d\");\r\n        q.add(\"e\");\r\n\r\n        System.out.println(\"从头部取出元素，并从队列里删除 &gt;&gt; \"+q.poll());    //a 从头部取出元素，并从队列里删除\r\n        System.out.println(\"删除后的长度 &gt;&gt; \"+q.size());    //4\r\n        System.out.println(\"取出头部元素 &gt;&gt; \"+q.peek());    //b\r\n        System.out.println(\"长度 &gt;&gt; \"+q.size());    //4\r\n        }\r\n}</code></pre>\r\n<p>打印结果：</p>\r\n<p>从头部取出元素，并从队列里删除 &gt;&gt; <span class=\"hljs-operator\">a</span></p>\r\n<p>删除后的长度 &gt;&gt; <span class=\"hljs-number\">4</span></p>\r\n<p>取出头部元素 &gt;&gt; b</p>\r\n<p>长度 &gt;&gt; <span class=\"hljs-number\">4</span></p>',6,0,0,0,0,0,'2018-05-27 01:40:15'),(24,11,3,'C3P0和dbutils数据库连接池封装的使用','<p>首先用数据库连接池管理Connection，我们就可以重复使用Connection了，有了连接池我们就可以不用自己创建Connection，&nbsp;<br />然后用完把它归还给连接池就行了，首先用c3p0数据库连接池，需要向项目中导入两个包：mchange-commons-java-0.2.11.jar和c3p0-0.9.5.2.jar，如果用的数据库是oracle的话，需要导入三个包需要再加上一个：c3p0-oracle-thin-extras-0.9.5.2.jar&nbsp;<br />这里附上我的百度云的c3p0的下载链接<a href=\"http://pan.baidu.com/s/1eStATf8\" target=\"_blank\" rel=\"noopener\">http://pan.baidu.com/s/1eStATf8</a>&nbsp;<br />然后在src文件夹下放置一个c3p0-config.xml的文件，这里附上代码：</p>\r\n<pre class=\"language-java\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\r\n&lt;c3p0-config&gt;\r\n    &lt;default-config&gt; 33 \r\n        &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt;\r\n        &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\r\n        &lt;property name=\"user\"&gt;root&lt;/property&gt;\r\n        &lt;property name=\"password\"&gt;dre@mtech1012&lt;/property&gt;\r\n\r\n        &lt;property name=\"acquireIncrement\"&gt;3&lt;/property&gt;\r\n        &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt;\r\n        &lt;property name=\"minPoolSize\"&gt;2&lt;/property&gt;\r\n        &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt;\r\n    &lt;/default-config&gt;\r\n&lt;/c3p0-config&gt;</code></pre>\r\n<p>然后就是修改数据库连接字符串和登陆数据库的账户和密码。然后就是把每一次&nbsp;<br />&nbsp;要连接到数据库的代码给封装到jdbcUtils类中，这样就可以直接调用获取数据的连接对象了。下面试jdbcUtils的代码了：</p>\r\n<pre class=\"language-java\"><code>import java.sql.Connection;\r\nimport java.sql.SQLException;\r\n\r\nimport javax.sql.DataSource;\r\n\r\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\r\n\r\n/**\r\n * 使用本类的方法，必须提供c3p0-copnfig.xml文件\r\n * @author qdmmy6\r\n */\r\npublic class JdbcUtils {\r\n    // 饿汉式\r\n    private static DataSource ds = new ComboPooledDataSource();\r\n\r\n    /**\r\n     * 它为null表示没有事务\r\n     * 它不为null表示有事务\r\n     * 当开启事务时，需要给它赋值\r\n     * 当结束事务时，需要给它赋值为null\r\n     * 并且在开启事务时，让dao的多个方法共享这个Connection\r\n     */\r\n    private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();\r\n\r\n    public static DataSource getDataSource() {\r\n        return ds;\r\n    }\r\n\r\n    /**\r\n     * dao使用本方法来获取连接\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    public static Connection getConnection() throws SQLException {\r\n        /*\r\n         * 如果有事务，返回当前事务的con\r\n         * 如果没有事务，通过连接池返回新的con\r\n         */\r\n        Connection con = tl.get();//获取当前线程的事务连接\r\n        if(con != null) return con;\r\n        return ds.getConnection();\r\n    }\r\n\r\n    /**\r\n     * 开启事务\r\n     * @throws SQLException \r\n     */\r\n    public static void beginTransaction() throws SQLException {\r\n        Connection con = tl.get();//获取当前线程的事务连接\r\n        if(con != null) throw new SQLException(\"已经开启了事务，不能重复开启！\");\r\n        con = ds.getConnection();//给con赋值，表示开启了事务\r\n        con.setAutoCommit(false);//设置为手动提交\r\n        tl.set(con);//把当前事务连接放到tl中\r\n    }\r\n\r\n    /**\r\n     * 提交事务\r\n     * @throws SQLException \r\n     */\r\n    public static void commitTransaction() throws SQLException {\r\n        Connection con = tl.get();//获取当前线程的事务连接\r\n        if(con == null) throw new SQLException(\"没有事务不能提交！\");\r\n        con.commit();//提交事务\r\n        con.close();//关闭连接\r\n        con = null;//表示事务结束！\r\n        tl.remove();\r\n    }\r\n\r\n    /**\r\n     * 回滚事务\r\n     * @throws SQLException \r\n     */\r\n    public static void rollbackTransaction() throws SQLException {\r\n        Connection con = tl.get();//获取当前线程的事务连接\r\n        if(con == null) throw new SQLException(\"没有事务不能回滚！\");\r\n        con.rollback();\r\n        con.close();\r\n        con = null;\r\n        tl.remove();\r\n    }\r\n\r\n    /**\r\n     * 释放Connection\r\n     * @param con\r\n     * @throws SQLException \r\n     */\r\n    public static void releaseConnection(Connection connection) throws SQLException {\r\n        Connection con = tl.get();//获取当前线程的事务连接\r\n        if(connection != con) {//如果参数连接，与当前事务连接不同，说明这个连接不是当前事务，可以关闭！\r\n            if(connection != null &amp;&amp;!connection.isClosed()) {//如果参数连接没有关闭，关闭之！\r\n                connection.close();\r\n            }\r\n        }\r\n    }\r\n}</code></pre>',3,0,0,0,0,NULL,'2018-05-27 01:42:24'),(25,11,1,'Spring中Aware系列接口','<p>（一）IOC容器管理bean，bean在IOC容器中。那么bean知不知道自己在IOC容器中的代号（id）呢？bean知不知道自己在哪个IOC容器中？能否通过bean获取它的IOC容器对象呢？简单来说就是：bean是否对Spring有知觉</p>\r\n<p>答：单纯的bean（未实现Aware系列接口）是没有知觉的；实现了Aware系列接口的bean可以访问Spring容器。&nbsp;<br />这些Aware系列接口增强了Spring bean的功能，但是也会造成对Spring框架的绑定，增大了与Spring框架的耦合度。&nbsp;<br />（Aware是&ldquo;意识到的，察觉到的&rdquo;的意思，实现了Aware系列接口表明：可以意识到、可以察觉到）&nbsp;<br />（二）首先，看一下Aware系列接口&nbsp;</p>\r\n<p><img src=\"upload/editor/1FDA08BDD8284D6087759E21BE2735A7.dib\" /></p>\r\n<p>(三）Aware系列接口的共性&nbsp;<br />（1）都以&ldquo;Aware&rdquo;结尾&nbsp;<br />（2）都是Aware接口的子接口，即都继承了Aware接口&nbsp;<br />（3）接口内均定义了一个set方法&nbsp;<br />（四）Aware系列接口的set方法&nbsp;<br />（1）父接口Aware中没有定义任何方法，只是一个标识接口</p>\r\n<pre class=\"language-java\"><code>public interface Aware {\r\n}</code></pre>\r\n<p>（2）观察一下这些set方法&nbsp;<br />ApplicationContextAware接口：</p>\r\n<pre class=\"language-java\"><code>public interface ApplicationContextAware extends Aware {\r\n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\r\n}</code></pre>\r\n<p>BeanNameAware接口：</p>\r\n<pre class=\"language-java\"><code>public interface BeanNameAware extends Aware {\r\n    void setBeanName(String name);\r\n}</code></pre>\r\n<p>BeanClassLoaderAware接口:</p>\r\n<pre class=\"language-java\"><code>public interface BeanClassLoaderAware extends Aware {\r\n    void setBeanClassLoader(ClassLoader classLoader);\r\n}</code></pre>\r\n<p>ApplicationContextAware接口：&ldquo;Aware&rdquo;前面的&ldquo;ApplicationContext&rdquo;就是我们需要Aware（知道，获取）的内容。&nbsp;<br />set方法的形参ApplicationContext applicationContext就用于接收我们需要获取的那个对象。&nbsp;<br />会把我们需要Aware的内容，注给set方法的形参，我们需要定义一个成员属性来保存形参。&nbsp;<br />（五）代码示例：</p>\r\n<pre class=\"language-java\"><code>//实现BeanNameAware接口，才能获取bean在IOC容器中的id\r\n//还可以实现ApplicationContextAware接口，用于获取bean所在的IOC容器\r\npublic class HelloWorld implements BeanNameAware{\r\n\r\n    private String beanName;\r\n    @Override\r\n    public void setBeanName(String name) {//id会被传给形参name\r\n        this.beanName=name;//把id保存在成员属性beanName中\r\n    }\r\n\r\n    public String getBeanName(){\r\n        return beanName;\r\n    }\r\n}</code></pre>\r\n<p>在 bean配置文件中，注册一个id为&ldquo;hello&rdquo;的bean：</p>\r\n<pre class=\"language-java\"><code></code></pre>\r\n<pre class=\"language-java\"><code> public static void main(String[] args) {\r\n        ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n        HelloWorld h=(HelloWorld)context.getBean(\"hello\");\r\n        System.out.println(h.getBeanName());\r\n    }</code></pre>\r\n<p>输出结果：&nbsp;<br />hello</p>\r\n<p>Aware系列接口，用于辅助Spring bean访问Spring容器；&nbsp;<br />Aware系列接口，都定义了一个set 方法，体现了set方法注入的思想；&nbsp;<br />这些接口的作用与@Autowired、@Resource等注解有点类似；&nbsp;<br />在Struts2中，也有Aware系列接口：RequestAware；SessionAware；ApplicationAware；ParameterAware等。这些接口的设计思想和Spring里面的Aware系列接口的设计思想是一致的。</p>',5,0,0,0,0,0,'2018-05-27 01:46:37'),(26,11,2,'如何提高逻辑思维能力？','<div>\r\n<div>\r\n<p><strong>我的回答是：写长文。</strong></p>\r\n<br />\r\n<p>能写出有质量有层次有主线的长文的能力是不局限于某一个专业和学科的，每一个领域都需要。一个连 5000 字原创文章都写不出来的人，就别谈什么思维理性了吧，那是个笑话。</p>\r\n<br />\r\n<p>写长文的背后，是你思考的观点和洞见，是你归纳出事物发展的规律和逻辑，是你在做事之后的反思，是你自己的社会阅历与见识，你需要花时间去体验，去总结，去思考，去研究，去整理。</p>\r\n<br />\r\n<p>不要以为脑子里想了就行了，没必要一一写出来。其实，在脑海里存在的都是一个个的散点，像一个个散着的珠子，或许每一个珠子都很亮很精致，但是他们毫无规律的散在地上，不但不易识别还有可能找不到。</p>\r\n<br />\r\n<p>但是写长文就像一根线，把所有的珠子能串起来，写的过程中，你需要注意措辞，注意前后的逻辑关系，注意各个角度的搭配&hellip;&hellip;这样的一个过程，对于提升自己的表达、思维、逻辑是非常有益的。</p>\r\n<br />\r\n<p>不论是做一次活动还是去做了一次兼职，或是读了一本书，把自己在整个过程中的思考一点点写下来，思考的质量也就会一点点进步，自己的深度才会增加。你也别问不知道该写什么怎么办，我们PPT圈的几个小伙伴完成一篇PPT都能把整个制作过程洋洋洒洒总结上几千字，从制作过程中的问题、求助、提高、技术、趣事、指点、成果等等角度来总结，完全可以开发成一堂PPT的课了，而且这样的总结发到微博上还能被转个上百次结识更多的圈子。什么叫高质量做事，这就是高质量。</p>\r\n<br />\r\n<p><strong>其实能够有这样一种好的心态，我们做事才能真正有收获，一件事情纯粹做了仅仅叫经历，一件事情做完了有自己对整个过程的思考和总结，才叫经验。</strong></p>\r\n<br />\r\n<p>这个世界有太多有经历的人，一件事情做十年还是一个模式，所以他有十年的经历；这个世界缺少的是有经验的人，或许一样要重复做事，但是他的感悟让他进步，可能下一次就可以脱离原有的模式、圈子、平台、级别，所以他有十年的经验。这就是思考带来的威力。</p>\r\n<br />\r\n<p>反正我是这种方式的切实受益者。写着写着，思维角度就打开了，深度渐渐也就有了，于是在做一些事情的时候，创意、角度、细节会把握得更好。<strong>思考总结不但是一种能力，更是一种态度，不断总结是为了更好前行。</strong></p>\r\n<br />\r\n<p>不要小看这些东西。不信你去试试，大多数人把一件事情后的总结写下来，无非就是按照时间顺序记录的流水账。流水账，迟早要流走，而只有深刻的总结、思考和延伸，才会刻在脑海里。这种总结能力会要求自己了解任何一个新领域时，先构造一个整体框架，再容纳各种细节。这样你接纳的碎片化信息越多，你丰富和调整你思考框架的机会越多，你整体思考的能力越强，于是经验就足了。</p>\r\n<br />\r\n<p>但是要特别指出，不要以为写长文的时候有个一二三就叫「逻辑」、「结构」。</p>\r\n<p>借用许纪霖老师曾经在接受参访中说过这样一段话：</p>\r\n<blockquote>我在参加一些博士论文答辩的过程中发现，现在有些学生很爱运用「 PPT 思维」。<br />这在工科学科和社会科学领域，尤其常见。过去一般的论文都是论证式的，有一种内在的逻辑，来证明自己的论证是合理的，它是一个整体性的东西。但这种 PPT 式的论文，表面看起来框架结构很科学，分为「1.1、 1.2、1.3&hellip;&hellip;」再分为「2.1、2.2、2.3&hellip;&hellip;」好像内容很整齐。<br />但我把它称为「虚假的整体性」，因为在这一点和那一点之间是没有逻辑关系的，它只是一个平面上的铺陈，没有深度，为什么要从这一点跳到那一点，也没有任何论证的过程。这样的论文，写起来很容易。</blockquote>\r\n<p>这是一种非常偷懒的做法。</p>\r\n<p>其实探究背后的根源，现在年轻人的知识体系越来越破碎，他们又缺乏一种把这些知识通过自己的思考贯通起来的能力，而论文又不能支离破碎，所以就用这种「虚假的整体性」来对付。</p>\r\n<br />\r\n<p>所以如果要训练自己的逻辑思维能力，提升结构化思考的水平，要经常安排封闭的时间段，至少半个小时，逼自己写长文章，而不是写碎片化微博，因为唯有这样才能保证结构化思考能力不下降。</p>\r\n<br />\r\n<p>所以有时候我写很长的文章，发到公众号上或许阅读量并不高，因为大家别说写长文，连看长文的耐心都没有了，但是我个人的提升却很大。我坚信如果不刻意保持这个能力，结果就会不是你解决问题的效率下降，就是你解决问题的质量下降。所以写长文可以逼你系统化深入思考一个大问题，让你把前因后果看得比一般人透彻，这样也可以让你做长期决策时不会浪费时间走弯路。</p>\r\n<br />\r\n<p>另附：我有过一次两个半小时的跨年演讲，分享了我9个方面的认知，其中第一个版块就是「结构化思考」，如果有兴趣请移步：<a class=\" wrap external\" href=\"https://link.zhihu.com/?target=https%3A//v.qq.com/x/page/c038161348x.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-za-detail-view-id=\"1043\">【老秦演讲】一个PPT主义者的成长故事Ⅰ_腾讯视频</a></p>\r\n<br />\r\n<p>以上。</p>\r\n</div>\r\n</div>',2,0,0,0,0,NULL,'2018-05-27 01:52:11'),(27,11,2,'Java 实习生（月薪 3k-5k 水平）应具备哪些知识、能力？','<div>\r\n<p>我真是看不下去了，这顶上说的都是啥？人家要3-5k的要求，你们再多写一点都快30-50k了。</p>\r\n<p>小兄弟，你相信我，3-5k的java需要学的东西就以下几点：</p>\r\n<p>1.java所有关键字知道意思，除了synchronized和volatile以外，都应当会应用。</p>\r\n<p>2.熟悉各种包装类，8种基本数据的包装类和String，都会应用。</p>\r\n<p>3.熟悉面向对象，毕竟java是最标准的面向对象语言。</p>\r\n<p>4.熟悉Spring框架下如何写业务代码，会写简单的sql（会写子查询会用join），完全不需要你自己能手搭一个出来。</p>\r\n<p>5.会用Eclipse，如果会用Idea更好。</p>\r\n<p>6.完了。</p>\r\n<p>如果你做到以上几点在一线城市以及杭州还特么找不到一个4k的实习，你把你的电脑你的IDE都砸到我的脑袋上，然后我把我自己的电脑一口一口吃掉。</p>\r\n<p>&nbsp;</p>\r\n<p>================================</p>\r\n<p>&nbsp;</p>\r\n<p>那又有好多人说自己做到的远远不止这些，怎么找不到呢？首先，请去北上广深杭。其次，别挑厂，广撒网。</p>\r\n<p>会到这些还远远达不到让你挑厂，这个水平拿到实习需要海投。如果你想去bat实习，请自行找出20k要求去达成。</p>\r\n</div>',6,0,0,0,0,NULL,'2018-05-27 01:54:18'),(28,11,2,'spring的加载机制？','<p>我一般问这个问题就区分出初级/高级开发了，很多10年经验的都答不出来。</p>\r\n<p>首先思考一个main方法中如何启动Spring：</p>\r\n<p>ApplicationContext ctx = new XmlApplicationContext(\"app.xml\");</p>\r\n<p>那么Web容器中如何启动Spring呢？</p>\r\n<p>&nbsp;</p>\r\n<p>方法1: 利用Spring自带的Servlet启动，配好Servlet，加载Servlet的时候，就初始化了WebApplicationContext；</p>\r\n<p>方法2: 利用Spring自带的Listener启动，配好Listener，加载Listener的时候，就初始化了WebApplicationContext。</p>\r\n<p>凡是回答Tomcat启动Spring的，连Servlet容器的概念都没理解，Tomcat根本不知道你用没用Spring。</p>',3,0,0,0,0,NULL,'2018-05-27 01:58:07'),(29,11,1,'Spring4.x推荐使用java配置，为什么推荐这种配置方式？与xml配置和注解配置相比有什么优势？','<p>早期Java的重点应用领域之一是企业级信息系统开发（因为这块来钱~~~），就是Java EE那块，这种系统的特点是主要运行于企业内部，系统规模通常较大，需要实现各种复杂多变的业务逻辑，还需要进行各种复杂的信息转换和流程、权限等控制，对于这种应用场景，将许多配置工作以XML文件形式进行&ldquo;外包&rdquo;，要比将逻辑直接写到代码中要方便。当然，这会导致出现很多的配置文件，管理起来比较困难。但对于中大型的项目来说，通常都有专门的人员，有相应的机制来统一管理和部署这些系统配置，相比动不动地改源码、编译、测试通过之后再重新部署，用XML可以省去很多工作，还是不错的。</p>\r\n<p>&nbsp;</p>\r\n<p>所以在那个时代，我们的印象就是中大型的项目大都用Java去开发，而.NET之类只用于小型项目。</p>\r\n<p>&nbsp;</p>\r\n<p>但后来情况不一样了，互联网应用迅速成为Java技术的主战场，而互联网应用有其特点：比如永远的BETA版，比如需要敏捷的持续迭代的开发流程等等。在这个时代，强调要将大的系统进行切分，灵活地部署和伸缩，比如微服务技术的流行就是例子。</p>\r\n<p>&nbsp;</p>\r\n<p>微服务架构，将大的单体应用拆分为多个小的相互协作的微服务，每个微服务都可以单独开发与部署，常见的是将微服务部署到Docker之类容器中，而一台Server可以跑多个容器，容器的启动、停止与替换都很方便，还有一堆各式各样的监控和管理各个容器和微服务运行状况的工具&hellip;&hellip;&lt;/p&gt;&lt;p&gt;由于每个微服务的功能职责明确，相互独立，结构单一稳定，代码规模也不会太大，再用XML的优势就不存在了，相反，统一用代码实现要清爽得多，需要修改时，改好代码，编译、测试、生成Docker镜像，然后启动&hellip;&hellip;，全流程都有相应的工具辅助。</p>\r\n<p>&nbsp;</p>\r\n<p>总结一下吧：使用XML还是使用代码完成配置工作，是由具体场景决定的。早期是&ldquo;重量级&rdquo;的规模较大的项目，XML的优势比较明显，而现在的应用则具有&rdquo;可伸缩&ldquo;，&rdquo;易扩展&ldquo;，&rdquo;持续演化&ldquo;，&rdquo;小粒度&ldquo;，&rdquo;动态组合&ldquo;等特性，相应的支持微服务架构的各种基础设施也都比较完备，弃用XML而采用代码进行配置也就顺理成章了，它能带来更多的好处。</p>',9,0,0,0,0,NULL,'2018-05-27 02:01:09');

/*Table structure for table `mto_users` */

DROP TABLE IF EXISTS `mto_users`;

CREATE TABLE `mto_users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `created` datetime DEFAULT NULL,
  `mobile` varchar(11) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `username` varchar(64) DEFAULT NULL,
  `name` varchar(64) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT 'default.png',
  `updated` datetime DEFAULT NULL,
  `gender` int(11) DEFAULT NULL,
  `signature` varchar(255) DEFAULT NULL,
  `last_login` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

/*Data for the table `mto_users` */

insert  into `mto_users`(`id`,`created`,`mobile`,`password`,`status`,`username`,`name`,`avatar`,`updated`,`gender`,`signature`,`last_login`) values (11,'2018-05-26 19:38:36',NULL,'81dc9bdb52d04dc20036dbd8313ed055',3,'admin','少年维特的烦恼','1928BB7E4B12463AB1973372B8B47A3C.jpg','2018-05-27 13:31:28',NULL,'这个人傻逼',NULL),(12,'2018-05-26 20:07:19',NULL,'202cb962ac59075b964b07152d234b70',0,'zmyqw','张明远','default.png','2018-05-27 00:27:20',NULL,'我是一个帅哥',NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
